---
title: React JS
description: Your first document
---

### _1. Что такое <mark class="hltr-r bg-red-300">React.js</mark>?_
<mark class="hltr-r">React</mark> — это JavaScript UI-библиотека, решающий проблему манипуляции с DOM-деревом, так как он использует более оптимизированную версию — Virtual DOM. К особенностям можно отнести компонентный подход, reusability компонентов и однонаправленный поток данных от родителя к чайлду
***
### _2. Что такое <mark class="hltr-r">Virtual DOM</mark>?_
<mark class="hltr-r">Vurtual DOM</mark> — легковесная копия оригинального DOM, помогает избежать прямых манипуляций с DOM-деревом. Он хранится в виде отдельного JS-объекта. При изменении компонента сначала обновляется <mark class="hltr-r">Virtual DOM</mark> объект, далее сравнение текущей версии <mark class="hltr-r">Virtual DOM</mark> с предыдущей и потом на основе этого сравнения точечно обновляются только те элементы, которые действительно изменились.
___
### _3. Обязателен ли <mark class="hltr-r">key</mark> в списках?_
Он необязательный, но по дефолту подставится <mark class="hltr-b">index</mark>, который не всегда является верным решением: порядок расположения элементов может изменяться, в итоге происходят баги с состоянием. Будет хорошо с уникальным id.
___
### _4. Что такое <mark class="hltr-r">useEffect</mark>?_
Хук, вызывающийся после монтировании компонента асинхронно и выполняет сайд-эффекты в ФК (запросы, события, изменения DOM-подписки)

> При <mark class="hltr-r">пустом массиве зависимостей</mark> эффект будет вызван только при монтировании компонента.
> 
> В случае <mark class="hltr-r">непустого массива зависимостей</mark> (мб какое-то вычисленное значение, состояние или проп) эффект выполняется только при изменении одной из указанных зависимостей.
> 
>  При <mark class="hltr-r">отсутствии массива зависимостей</mark> эффект выполняется после каждого рендера.

___
### _5. разница между <mark class="hltr-r">useMemo</mark> и <mark class="hltr-r">useCallback</mark>?_
<mark class="hltr-r">useCallbcak</mark> необходим для мемоизации **функции**, принимает какой-либо callback-функцию и мемоизирует ссылку, то есть при каждом рендере ссылка на функцию будет неизменна. Принимает массив зависимостей и ссылка будет изменяться при изменении массива этих зависимостей.

<mark class="hltr-b">useMemo</mark> принимает callback и мемоизирует возвращаемое из него **значение**. Бессмысленно обворачивать примитивные значения
___
### _6. Что такое <mark class="hltr-r">React Context</mark>?_
Он позволяет создавать глобальное состояние без сторонних библиотек во избежание prop drilling и с помощью хука <mark class="hltr-b">useContext()</mark> получать состояние и изменять его.

> <mark class="hltr-r">Prop drilling</mark> — перебрасывание данных из одного компонента через нескольких компоненты. Обычно вызывает проблемы с производительностью и для последующей поддержки и расширения кодовых баз React.

### _7. Расскажи про <mark class="hltr-r">Жизненный цикл React компонентов</mark>?_
___
![[Life-Cycle-React-C-nents.excalidraw|1000]]
___
### _8. При каких условиях происходит <mark class="hltr-r">ре-рендер компонентов</mark> в React.js?_
- Изменение состояния (state) компонента.
- Изменение пропсов (props) компонента.
- Ре-рендер родительского компонента.
- Измерение хука.
- Изменение контекста.
- Вызов метода `forceUpdate()` в классовых компонентах.
___
### _9. Что такое <mark class="hltr-r">UseState</mark>?_
Хук для работы с локальным состоянием компонента. Принимает <mark class="hltr-b">initialValue</mark> и возвращает текущее значение <mark class="hltr-b">(state)</mark> и callback-функцию, изменяющий текущее значение <mark class="hltr-b">setState</mark>. После каждого каждого вызова <mark class="hltr-b">setState</mark> ре-рендрится компонент.

___
### _10. Что такое <mark class="hltr-r">useRef</mark>?_
Хук, возвращающий ref-объект со свойством `current`. С помощью него можно получать доступ к DOM-объекту, либо сохранять какие-либо значения. Мутированное свойство `current` не вызывает ре-рендер, то есть это один и тот же объект при каждом рендере.
___
### _11. Что такое <mark class="hltr-r">memo</mark>?_
Мемоизация в React — это процесс кэширования результатов вычислений. Она используется для оптимизации рендеринга компонентов.
___
### _12. Что такое <mark class="hltr-r">useLayoutEffect</mark>?_
То же самое, что и [[#_4. Что такое <mark class="hltr-r">useEffect</mark>?_|useEffect]], но отличие в том, что вызывается синхронно, блокируя отрисовку браузера (<mark class="hltr-b">useEffect</mark> всё наоборот). <mark class="hltr-r">useLayoutEffect</mark> срабатывает, когда элементы уже появились в V-DOM, но ещё не отрисовались браузером.
___
### _13. Сравнение функционального и классового подхода написания компонентов_

| Ф                                                | К                                       |
| ------------------------------------------------ | --------------------------------------- |
| Хуки                                             | Методы жизненного цикла                 |
| Возвращение JSX-разметки                         | Вызов метода `render`                   |
| -                                                | Использование `this` и `bind` контекста |
| Создание обработчиков событий при каждом рендере | Инициализация только 1 раз              |


___
### _14. Что такое JSX_
Это HTML-разметка в React-коде. Компилируется с помощью Babel, вызвав функцию `React.createElement()` 
___
### _15. Что такое HOC?_ 
Это функция, которая на входе принимает один компонент, а на выходе возвращает новый с более расширенным функционалом. 

_hoc_ — это функция, ожидающая в качестве параметров входной компонент, который оборачивается в другой, объявленный в теле функции, компонент, выступающий в роли возвращаемого из функции выходным значения.

Слово “оборачивание”, применимое относительно компонентов, означает, что один компонент отрисовывает (рендерит) другой компонент, со всеми вытекающими из этого процесса (проксирования). За счет того, что входной компонент оборачивается в выходной, достигается расширение его и/или общего функционала. Кроме того, это позволяет устанавливать входному компоненту как зависимости, так и данные, полученные из внешних сервисов.

___
### _14. Либы для анимаций?_
Framer Motion, React Spring, React Move.
___
### _15.  SOLID в React?_

| Принцип                                                     | Объяснение                                                                                                                                                                                                                        |
| ----------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| S (Single Responsibility: Принцип единой ответственности)   | Если есть компонент, отображающий список задач и одновременно управляет состоянием фильтрации, разделить его на два компонента: один для отображения списка задач (TaskList), другой для управления фильтром (Task Filter). |
| O (Open-Closed: Принцип открытости-закрытости)              | Использовать композицию для добавления новой функциональности к компоненту вместо его изменения.                                                                                                                                  |
| L (Liskov Substitution: Принцип подстановки Барбары Лисков) | В значительной степени зависит от наследования классов для определения отношений супертипа и подтипа, но он не очень применим в React, поскольку мы почти никогда не имеем дело с классами, не говоря уже о наследовании классов. |
| I (Interface Segregation: Принцип разделения интерфейса)    | «Компоненты не должны зависеть от пропсов, которые они не используют».                                                                                                                                                            |
| D (Dependency Inversion: Принцип инверсии зависимостей)     | Использовать контексты и провайдеры для инверсии зависимостей.                                                                                                                                                                    |
___
### _16. _ ?_

___
### _14. _ ?_

___
### _14. _ ?_

___
### _14. _ ?_

___
### _14. _ ?_

___
### _14. _ ?_

___
### _14. _ ?_

___
### _14. _ ?_

___
### _14. _ ?_

___

